<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ariadne.message.parser.twilight API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ariadne.message.parser.twilight</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import argparse
import inspect
import re
import shlex
import string
from copy import deepcopy
from types import TracebackType
from typing import (
    Dict,
    Generic,
    Iterable,
    List,
    NoReturn,
    Optional,
    Tuple,
    Type,
    TypedDict,
    TypeVar,
    Union,
)

from graia.broadcast.entities.dispatcher import BaseDispatcher
from graia.broadcast.exceptions import ExecutionStop
from graia.broadcast.interfaces.dispatcher import DispatcherInterface

from ...event.message import MessageEvent
from ..chain import MessageChain
from ..element import Element
from .pattern import ArgumentMatch, ElementMatch, FullMatch, Match, RegexMatch


class _TwilightParser(argparse.ArgumentParser):
    def error(self, message) -&gt; NoReturn:
        raise ValueError(message)

    def accept_type(self, action_str: str) -&gt; bool:
        action_cls: type = self._registry_get(&#34;action&#34;, action_str, action_str)
        action_init_sig = inspect.signature(action_cls.__init__)
        if &#34;type&#34; not in action_init_sig.parameters:
            return False
        return True


class _ArgumentMatchType:
    def __init__(
        self, match: ArgumentMatch, regex: re.Pattern, mapping: Dict[str, Element]
    ):
        self.match = match
        self.regex: re.Pattern = regex
        self.mapping: Dict[str, Element] = mapping

    def __call__(self, string: str) -&gt; MessageChain:
        if self.regex and not self.regex.fullmatch(string):
            raise ValueError(f&#34;{string} not matching {self.regex.pattern}&#34;)
        return MessageChain.fromMappingString(string, self.mapping)


class Sparkle:
    __dict__: Dict[str, Match]

    def __init__(
        self,
        check_args: Iterable[Match] = (),
        matches: Optional[Union[Dict[str, Match], Iterable[Tuple[str, Match]]]] = None,
    ):
        if matches is None or isinstance(matches, dict):
            match_map: Dict[str, Match] = matches or {
                k: v for k, v in self.__class__.__dict__.items() if isinstance(v, Match)
            }
        else:
            match_map: Dict[str, Match] = {k: v for k, v in matches}
        match_map = {
            f&#34;_check_{i}&#34;: val for i, val in enumerate(check_args)
        } | match_map  # ensure check args come first

        if any(
            k.startswith(&#34;_&#34;)
            and not re.fullmatch(r&#34;_check_(\d+)&#34;, k)
            or k[0] in string.digits
            for k in match_map.keys()
        ):
            raise ValueError(&#34;Invalid Match object name!&#34;)

        group_cnt: int = 0
        pattern_list: List[str] = []

        self._regex_match_list: List[Tuple[str, Union[RegexMatch, FullMatch], int]] = []
        self._args_map: Dict[str, Tuple[ArgumentMatch, str]] = {}

        for k, v in match_map.items():
            if isinstance(v, Match):
                if isinstance(v, ArgumentMatch):
                    self._args_map[v.name] = (v, k)
                else:
                    self._regex_match_list.append((k, v, group_cnt + 1))
                    group_cnt += re.compile(v.gen_regex()).groups
                    pattern_list.append(v.gen_regex())

        self._regex_pattern = &#34;&#34;.join(pattern_list)
        self._regex = re.compile(self._regex_pattern)

    def __repr__(self) -&gt; str:
        repr_dict: Dict[str, Match] = {
            k: v for k, v in self.__dict__.items() if isinstance(v, Match)
        }
        return f&#34;&lt;Sparkle: {repr_dict}&gt;&#34;

    def build_arg_parser(self, elem_mapping: Dict[str, Element]) -&gt; _TwilightParser:
        arg_parser = _TwilightParser(exit_on_error=False)
        for match, _ in self._args_map.values():
            add_argument_data = {
                &#34;action&#34;: match.action,
                &#34;nargs&#34;: match.nargs,
                &#34;const&#34;: match.const,
                &#34;default&#34;: match.default,
                &#34;required&#34;: not match.optional,
            } | (
                {&#34;type&#34;: _ArgumentMatchType(match, match.regex, elem_mapping)}
                if arg_parser.accept_type(match.action)
                else {}
            )
            arg_parser.add_argument(*match.pattern, **add_argument_data)
        return arg_parser

    def dump_namespace(self, namespace: argparse.Namespace) -&gt; None:
        for arg_name, val_tuple in self._args_map.items():
            match, sparkle_name = val_tuple
            namespace_val = getattr(namespace, arg_name, None)
            if arg_name in namespace.__dict__:
                setattr(
                    self,
                    sparkle_name,
                    match.clone(namespace_val, bool(namespace_val)),
                )

    def match_regex(
        self, elem_mapping: Dict[str, Element], arg_list: List[str]
    ) -&gt; None:
        if self._regex_pattern:
            if regex_match := self._regex.fullmatch(&#34; &#34;.join(arg_list)):
                for name, match, index in self._regex_match_list:
                    current = regex_match.group(index) or &#34;&#34;
                    if isinstance(match, ElementMatch):
                        if current:
                            index = re.fullmatch(&#34;\b(\\d+)_\\w+\b&#34;, current).group(1)
                            result = elem_mapping[int(index)]
                        else:
                            result = None
                    else:
                        result = MessageChain.fromMappingString(current, elem_mapping)
                    if isinstance(match, RegexMatch):
                        setattr(  # sparkle.{name} = toMessageChain(current)
                            self,
                            name,
                            match.clone(
                                result=result,
                                matched=bool(current),
                                re_match=re.match(match.pattern, current),
                            ),
                        )
                    else:
                        setattr(
                            self,
                            name,
                            match.clone(
                                result=result,
                                matched=bool(current),
                            ),
                        )
            else:
                raise ValueError(f&#34;Regex not matching: {self._regex_pattern}&#34;)


T_Sparkle = TypeVar(&#34;T_Sparkle&#34;, bound=Sparkle)


class _TwilightLocalStorage(TypedDict):
    sparkle: Optional[Sparkle]


class Twilight(BaseDispatcher, Generic[T_Sparkle]):
    &#34;&#34;&#34;
    暮光.
    &#34;&#34;&#34;

    def __init__(
        self,
        sparkle: Union[Type[T_Sparkle], T_Sparkle],
        remove_source: bool = True,
        remove_quote: bool = True,
        remove_extra_space: bool = False,
    ):
        &#34;&#34;&#34;本魔法方法用于初始化本实例.

        Args:
            sparkle (Optional[Type[T_Sparkle]], optional): Sparkle 的子类, 用于生成 Sparkle.
            remove_source (bool, optional): 是否移除消息链中的 Source 元素. 默认为 True.
            remove_quote (bool, optional): 处理时是否要移除消息链的 Quote 元素. 默认为 True.
            remove_extra_space (bool, optional): 是否移除 Quote At AtAll 的多余空格. 默认为 False.
        &#34;&#34;&#34;
        if isinstance(sparkle, Sparkle):
            self.sparkle_root = sparkle
        else:
            self.sparkle_root = sparkle()
        self.map_params = {
            &#34;remove_source&#34;: remove_source,
            &#34;remove_quote&#34;: remove_quote,
            &#34;remove_extra_space&#34;: remove_extra_space,
        }

    def gen_sparkle(self, chain: MessageChain) -&gt; T_Sparkle:
        sparkle = deepcopy(self.sparkle_root)
        mapping_str, elem_mapping = chain.asMappingString(**self.map_params)
        arg_parser = sparkle.build_arg_parser(elem_mapping)
        str_list = shlex.split(mapping_str)
        try:
            namespace, arg_list = arg_parser.parse_known_args(str_list)
            sparkle.dump_namespace(namespace)
        except Exception:
            raise
        else:
            sparkle.match_regex(elem_mapping, arg_list)
        return sparkle

    def beforeExecution(self, interface: &#34;DispatcherInterface[MessageEvent]&#34;):
        if not isinstance(interface.event, MessageEvent):
            raise ExecutionStop()
        local_storage: _TwilightLocalStorage = (
            interface.broadcast.decorator_interface.local_storage
        )
        chain: MessageChain = interface.event.messageChain
        try:
            local_storage[&#34;sparkle&#34;] = self.gen_sparkle(chain)
        except:
            raise ExecutionStop()

    async def catch(
        self, interface: &#34;DispatcherInterface[MessageEvent]&#34;
    ) -&gt; Optional[T_Sparkle]:
        local_storage: _TwilightLocalStorage = (
            interface.broadcast.decorator_interface.local_storage
        )
        sparkle = local_storage[&#34;sparkle&#34;]
        if issubclass(interface.annotation, Sparkle):
            return sparkle
        if issubclass(interface.annotation, Twilight):
            return self
        if isinstance(interface.annotation, Match):
            if hasattr(sparkle, interface.name):
                match: Match = getattr(sparkle, interface.name)
                if isinstance(match, interface.annotation):
                    return match

    def afterExecution(
        self,
        interface: &#34;DispatcherInterface&#34;,
        exception: Optional[Exception],
        tb: Optional[TracebackType],
    ):
        if &#34;sparkle&#34; in interface.broadcast.decorator_interface.local_storage:
            del interface.broadcast.decorator_interface.local_storage[&#34;sparkle&#34;]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ariadne.message.parser.twilight.Sparkle"><code class="flex name class">
<span>class <span class="ident">Sparkle</span></span>
<span>(</span><span>check_args: Iterable[<a title="ariadne.message.parser.pattern.Match" href="pattern.html#ariadne.message.parser.pattern.Match">Match</a>] = (), matches: Union[Dict[str, <a title="ariadne.message.parser.pattern.Match" href="pattern.html#ariadne.message.parser.pattern.Match">Match</a>], Iterable[Tuple[str, <a title="ariadne.message.parser.pattern.Match" href="pattern.html#ariadne.message.parser.pattern.Match">Match</a>]], ForwardRef(None)] = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Sparkle:
    __dict__: Dict[str, Match]

    def __init__(
        self,
        check_args: Iterable[Match] = (),
        matches: Optional[Union[Dict[str, Match], Iterable[Tuple[str, Match]]]] = None,
    ):
        if matches is None or isinstance(matches, dict):
            match_map: Dict[str, Match] = matches or {
                k: v for k, v in self.__class__.__dict__.items() if isinstance(v, Match)
            }
        else:
            match_map: Dict[str, Match] = {k: v for k, v in matches}
        match_map = {
            f&#34;_check_{i}&#34;: val for i, val in enumerate(check_args)
        } | match_map  # ensure check args come first

        if any(
            k.startswith(&#34;_&#34;)
            and not re.fullmatch(r&#34;_check_(\d+)&#34;, k)
            or k[0] in string.digits
            for k in match_map.keys()
        ):
            raise ValueError(&#34;Invalid Match object name!&#34;)

        group_cnt: int = 0
        pattern_list: List[str] = []

        self._regex_match_list: List[Tuple[str, Union[RegexMatch, FullMatch], int]] = []
        self._args_map: Dict[str, Tuple[ArgumentMatch, str]] = {}

        for k, v in match_map.items():
            if isinstance(v, Match):
                if isinstance(v, ArgumentMatch):
                    self._args_map[v.name] = (v, k)
                else:
                    self._regex_match_list.append((k, v, group_cnt + 1))
                    group_cnt += re.compile(v.gen_regex()).groups
                    pattern_list.append(v.gen_regex())

        self._regex_pattern = &#34;&#34;.join(pattern_list)
        self._regex = re.compile(self._regex_pattern)

    def __repr__(self) -&gt; str:
        repr_dict: Dict[str, Match] = {
            k: v for k, v in self.__dict__.items() if isinstance(v, Match)
        }
        return f&#34;&lt;Sparkle: {repr_dict}&gt;&#34;

    def build_arg_parser(self, elem_mapping: Dict[str, Element]) -&gt; _TwilightParser:
        arg_parser = _TwilightParser(exit_on_error=False)
        for match, _ in self._args_map.values():
            add_argument_data = {
                &#34;action&#34;: match.action,
                &#34;nargs&#34;: match.nargs,
                &#34;const&#34;: match.const,
                &#34;default&#34;: match.default,
                &#34;required&#34;: not match.optional,
            } | (
                {&#34;type&#34;: _ArgumentMatchType(match, match.regex, elem_mapping)}
                if arg_parser.accept_type(match.action)
                else {}
            )
            arg_parser.add_argument(*match.pattern, **add_argument_data)
        return arg_parser

    def dump_namespace(self, namespace: argparse.Namespace) -&gt; None:
        for arg_name, val_tuple in self._args_map.items():
            match, sparkle_name = val_tuple
            namespace_val = getattr(namespace, arg_name, None)
            if arg_name in namespace.__dict__:
                setattr(
                    self,
                    sparkle_name,
                    match.clone(namespace_val, bool(namespace_val)),
                )

    def match_regex(
        self, elem_mapping: Dict[str, Element], arg_list: List[str]
    ) -&gt; None:
        if self._regex_pattern:
            if regex_match := self._regex.fullmatch(&#34; &#34;.join(arg_list)):
                for name, match, index in self._regex_match_list:
                    current = regex_match.group(index) or &#34;&#34;
                    if isinstance(match, ElementMatch):
                        if current:
                            index = re.fullmatch(&#34;\b(\\d+)_\\w+\b&#34;, current).group(1)
                            result = elem_mapping[int(index)]
                        else:
                            result = None
                    else:
                        result = MessageChain.fromMappingString(current, elem_mapping)
                    if isinstance(match, RegexMatch):
                        setattr(  # sparkle.{name} = toMessageChain(current)
                            self,
                            name,
                            match.clone(
                                result=result,
                                matched=bool(current),
                                re_match=re.match(match.pattern, current),
                            ),
                        )
                    else:
                        setattr(
                            self,
                            name,
                            match.clone(
                                result=result,
                                matched=bool(current),
                            ),
                        )
            else:
                raise ValueError(f&#34;Regex not matching: {self._regex_pattern}&#34;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ariadne.message.parser.twilight.Sparkle.build_arg_parser"><code class="name flex">
<span>def <span class="ident">build_arg_parser</span></span>(<span>self, elem_mapping: Dict[str, <a title="ariadne.message.element.Element" href="../element.html#ariadne.message.element.Element">Element</a>]) ‑> ariadne.message.parser.twilight._TwilightParser</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_arg_parser(self, elem_mapping: Dict[str, Element]) -&gt; _TwilightParser:
    arg_parser = _TwilightParser(exit_on_error=False)
    for match, _ in self._args_map.values():
        add_argument_data = {
            &#34;action&#34;: match.action,
            &#34;nargs&#34;: match.nargs,
            &#34;const&#34;: match.const,
            &#34;default&#34;: match.default,
            &#34;required&#34;: not match.optional,
        } | (
            {&#34;type&#34;: _ArgumentMatchType(match, match.regex, elem_mapping)}
            if arg_parser.accept_type(match.action)
            else {}
        )
        arg_parser.add_argument(*match.pattern, **add_argument_data)
    return arg_parser</code></pre>
</details>
</dd>
<dt id="ariadne.message.parser.twilight.Sparkle.dump_namespace"><code class="name flex">
<span>def <span class="ident">dump_namespace</span></span>(<span>self, namespace: argparse.Namespace) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump_namespace(self, namespace: argparse.Namespace) -&gt; None:
    for arg_name, val_tuple in self._args_map.items():
        match, sparkle_name = val_tuple
        namespace_val = getattr(namespace, arg_name, None)
        if arg_name in namespace.__dict__:
            setattr(
                self,
                sparkle_name,
                match.clone(namespace_val, bool(namespace_val)),
            )</code></pre>
</details>
</dd>
<dt id="ariadne.message.parser.twilight.Sparkle.match_regex"><code class="name flex">
<span>def <span class="ident">match_regex</span></span>(<span>self, elem_mapping: Dict[str, <a title="ariadne.message.element.Element" href="../element.html#ariadne.message.element.Element">Element</a>], arg_list: List[str]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match_regex(
    self, elem_mapping: Dict[str, Element], arg_list: List[str]
) -&gt; None:
    if self._regex_pattern:
        if regex_match := self._regex.fullmatch(&#34; &#34;.join(arg_list)):
            for name, match, index in self._regex_match_list:
                current = regex_match.group(index) or &#34;&#34;
                if isinstance(match, ElementMatch):
                    if current:
                        index = re.fullmatch(&#34;\b(\\d+)_\\w+\b&#34;, current).group(1)
                        result = elem_mapping[int(index)]
                    else:
                        result = None
                else:
                    result = MessageChain.fromMappingString(current, elem_mapping)
                if isinstance(match, RegexMatch):
                    setattr(  # sparkle.{name} = toMessageChain(current)
                        self,
                        name,
                        match.clone(
                            result=result,
                            matched=bool(current),
                            re_match=re.match(match.pattern, current),
                        ),
                    )
                else:
                    setattr(
                        self,
                        name,
                        match.clone(
                            result=result,
                            matched=bool(current),
                        ),
                    )
        else:
            raise ValueError(f&#34;Regex not matching: {self._regex_pattern}&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ariadne.message.parser.twilight.Twilight"><code class="flex name class">
<span>class <span class="ident">Twilight</span></span>
<span>(</span><span>sparkle: Union[Type[~T_Sparkle], ~T_Sparkle], remove_source: bool = True, remove_quote: bool = True, remove_extra_space: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>暮光.</p>
<p>本魔法方法用于初始化本实例.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sparkle</code></strong> :&ensp;<code>Optional[Type[T_Sparkle]]</code>, optional</dt>
<dd>Sparkle 的子类, 用于生成 Sparkle.</dd>
<dt><strong><code>remove_source</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>是否移除消息链中的 Source 元素. 默认为 True.</dd>
<dt><strong><code>remove_quote</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>处理时是否要移除消息链的 Quote 元素. 默认为 True.</dd>
<dt><strong><code>remove_extra_space</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>是否移除 Quote At AtAll 的多余空格. 默认为 False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Twilight(BaseDispatcher, Generic[T_Sparkle]):
    &#34;&#34;&#34;
    暮光.
    &#34;&#34;&#34;

    def __init__(
        self,
        sparkle: Union[Type[T_Sparkle], T_Sparkle],
        remove_source: bool = True,
        remove_quote: bool = True,
        remove_extra_space: bool = False,
    ):
        &#34;&#34;&#34;本魔法方法用于初始化本实例.

        Args:
            sparkle (Optional[Type[T_Sparkle]], optional): Sparkle 的子类, 用于生成 Sparkle.
            remove_source (bool, optional): 是否移除消息链中的 Source 元素. 默认为 True.
            remove_quote (bool, optional): 处理时是否要移除消息链的 Quote 元素. 默认为 True.
            remove_extra_space (bool, optional): 是否移除 Quote At AtAll 的多余空格. 默认为 False.
        &#34;&#34;&#34;
        if isinstance(sparkle, Sparkle):
            self.sparkle_root = sparkle
        else:
            self.sparkle_root = sparkle()
        self.map_params = {
            &#34;remove_source&#34;: remove_source,
            &#34;remove_quote&#34;: remove_quote,
            &#34;remove_extra_space&#34;: remove_extra_space,
        }

    def gen_sparkle(self, chain: MessageChain) -&gt; T_Sparkle:
        sparkle = deepcopy(self.sparkle_root)
        mapping_str, elem_mapping = chain.asMappingString(**self.map_params)
        arg_parser = sparkle.build_arg_parser(elem_mapping)
        str_list = shlex.split(mapping_str)
        try:
            namespace, arg_list = arg_parser.parse_known_args(str_list)
            sparkle.dump_namespace(namespace)
        except Exception:
            raise
        else:
            sparkle.match_regex(elem_mapping, arg_list)
        return sparkle

    def beforeExecution(self, interface: &#34;DispatcherInterface[MessageEvent]&#34;):
        if not isinstance(interface.event, MessageEvent):
            raise ExecutionStop()
        local_storage: _TwilightLocalStorage = (
            interface.broadcast.decorator_interface.local_storage
        )
        chain: MessageChain = interface.event.messageChain
        try:
            local_storage[&#34;sparkle&#34;] = self.gen_sparkle(chain)
        except:
            raise ExecutionStop()

    async def catch(
        self, interface: &#34;DispatcherInterface[MessageEvent]&#34;
    ) -&gt; Optional[T_Sparkle]:
        local_storage: _TwilightLocalStorage = (
            interface.broadcast.decorator_interface.local_storage
        )
        sparkle = local_storage[&#34;sparkle&#34;]
        if issubclass(interface.annotation, Sparkle):
            return sparkle
        if issubclass(interface.annotation, Twilight):
            return self
        if isinstance(interface.annotation, Match):
            if hasattr(sparkle, interface.name):
                match: Match = getattr(sparkle, interface.name)
                if isinstance(match, interface.annotation):
                    return match

    def afterExecution(
        self,
        interface: &#34;DispatcherInterface&#34;,
        exception: Optional[Exception],
        tb: Optional[TracebackType],
    ):
        if &#34;sparkle&#34; in interface.broadcast.decorator_interface.local_storage:
            del interface.broadcast.decorator_interface.local_storage[&#34;sparkle&#34;]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>graia.broadcast.entities.dispatcher.BaseDispatcher</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="ariadne.message.parser.twilight.Twilight.mixin"><code class="name">var <span class="ident">mixin</span> : List[Union[graia.broadcast.entities.dispatcher.BaseDispatcher, Type[graia.broadcast.entities.dispatcher.BaseDispatcher]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ariadne.message.parser.twilight.Twilight.afterExecution"><code class="name flex">
<span>def <span class="ident">afterExecution</span></span>(<span>self, interface: DispatcherInterface, exception: Optional[Exception], tb: Optional[traceback])</span>
</code></dt>
<dd>
<div class="desc"><p>生命周期钩子: 在整个执行流程(包括参数解析)完成(包含因异常被抛出而退出)后被调用.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>interface</code></strong> :&ensp;<code>DispatcherInterface</code></dt>
<dd><code>Dispatcher</code> 服务的主要对象, 可以从其中获取以下信息:</dd>
</dl>
<ul>
<li>当前解析中的参数的信息;</li>
<li>
<dl>
<dt>当前执行的信息, 比如正在处理的事件, <code>Listener</code>/<code>ExecTarget</code> etc.;</dt>
<dt><strong><code>exception</code></strong> :&ensp;<code>Optional[Exception]</code></dt>
<dd>可能存在的异常对象, 若为 None 则表示无异常被抛出, 执行顺利完成.</dd>
</dl>
</li>
</ul>
<dl>
<dt><strong><code>tb</code></strong> :&ensp;<code>Optional[TracebackType]</code></dt>
<dd>可能存在的异常堆栈对象, 若为 None 则表示无异常被抛出, 执行顺利完成.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def afterExecution(
    self,
    interface: &#34;DispatcherInterface&#34;,
    exception: Optional[Exception],
    tb: Optional[TracebackType],
):
    if &#34;sparkle&#34; in interface.broadcast.decorator_interface.local_storage:
        del interface.broadcast.decorator_interface.local_storage[&#34;sparkle&#34;]</code></pre>
</details>
</dd>
<dt id="ariadne.message.parser.twilight.Twilight.beforeExecution"><code class="name flex">
<span>def <span class="ident">beforeExecution</span></span>(<span>self, interface: DispatcherInterface[MessageEvent])</span>
</code></dt>
<dd>
<div class="desc"><p>生命周期钩子: 在整个执行流程(包括参数解析)开始前被调用</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>interface</code></strong> :&ensp;<code>DispatcherInterface</code></dt>
<dd><code>Dispatcher</code> 服务的主要对象, 可以从其中获取以下信息:</dd>
</dl>
<ul>
<li>当前解析中的参数的信息;</li>
<li>当前执行的信息, 比如正在处理的事件, <code>Listener</code>/<code>ExecTarget</code> etc.;</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def beforeExecution(self, interface: &#34;DispatcherInterface[MessageEvent]&#34;):
    if not isinstance(interface.event, MessageEvent):
        raise ExecutionStop()
    local_storage: _TwilightLocalStorage = (
        interface.broadcast.decorator_interface.local_storage
    )
    chain: MessageChain = interface.event.messageChain
    try:
        local_storage[&#34;sparkle&#34;] = self.gen_sparkle(chain)
    except:
        raise ExecutionStop()</code></pre>
</details>
</dd>
<dt id="ariadne.message.parser.twilight.Twilight.catch"><code class="name flex">
<span>async def <span class="ident">catch</span></span>(<span>self, interface: DispatcherInterface[MessageEvent]) ‑> Optional[~T_Sparkle]</span>
</code></dt>
<dd>
<div class="desc"><p>该方法可以是 <code>staticmethod</code>, <code>classmethod</code> 亦或是普通的方法/函数.
唯一的要求是 <code>Dispatcher.catch</code> 获取到的必须为一可调用异步 Callable.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>interface</code></strong> :&ensp;<code>DispatcherInterface</code></dt>
<dd><code>Dispatcher</code> 服务的主要对象, 可以从其中获取以下信息:</dd>
</dl>
<ul>
<li>当前解析中的参数的信息;</li>
<li>当前执行的信息, 比如正在处理的事件, <code>Listener</code>/<code>ExecTarget</code> etc.;</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def catch(
    self, interface: &#34;DispatcherInterface[MessageEvent]&#34;
) -&gt; Optional[T_Sparkle]:
    local_storage: _TwilightLocalStorage = (
        interface.broadcast.decorator_interface.local_storage
    )
    sparkle = local_storage[&#34;sparkle&#34;]
    if issubclass(interface.annotation, Sparkle):
        return sparkle
    if issubclass(interface.annotation, Twilight):
        return self
    if isinstance(interface.annotation, Match):
        if hasattr(sparkle, interface.name):
            match: Match = getattr(sparkle, interface.name)
            if isinstance(match, interface.annotation):
                return match</code></pre>
</details>
</dd>
<dt id="ariadne.message.parser.twilight.Twilight.gen_sparkle"><code class="name flex">
<span>def <span class="ident">gen_sparkle</span></span>(<span>self, chain: <a title="ariadne.message.chain.MessageChain" href="../chain.html#ariadne.message.chain.MessageChain">MessageChain</a>) ‑> ~T_Sparkle</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_sparkle(self, chain: MessageChain) -&gt; T_Sparkle:
    sparkle = deepcopy(self.sparkle_root)
    mapping_str, elem_mapping = chain.asMappingString(**self.map_params)
    arg_parser = sparkle.build_arg_parser(elem_mapping)
    str_list = shlex.split(mapping_str)
    try:
        namespace, arg_list = arg_parser.parse_known_args(str_list)
        sparkle.dump_namespace(namespace)
    except Exception:
        raise
    else:
        sparkle.match_regex(elem_mapping, arg_list)
    return sparkle</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ariadne.message.parser" href="index.html">ariadne.message.parser</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ariadne.message.parser.twilight.Sparkle" href="#ariadne.message.parser.twilight.Sparkle">Sparkle</a></code></h4>
<ul class="">
<li><code><a title="ariadne.message.parser.twilight.Sparkle.build_arg_parser" href="#ariadne.message.parser.twilight.Sparkle.build_arg_parser">build_arg_parser</a></code></li>
<li><code><a title="ariadne.message.parser.twilight.Sparkle.dump_namespace" href="#ariadne.message.parser.twilight.Sparkle.dump_namespace">dump_namespace</a></code></li>
<li><code><a title="ariadne.message.parser.twilight.Sparkle.match_regex" href="#ariadne.message.parser.twilight.Sparkle.match_regex">match_regex</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ariadne.message.parser.twilight.Twilight" href="#ariadne.message.parser.twilight.Twilight">Twilight</a></code></h4>
<ul class="">
<li><code><a title="ariadne.message.parser.twilight.Twilight.afterExecution" href="#ariadne.message.parser.twilight.Twilight.afterExecution">afterExecution</a></code></li>
<li><code><a title="ariadne.message.parser.twilight.Twilight.beforeExecution" href="#ariadne.message.parser.twilight.Twilight.beforeExecution">beforeExecution</a></code></li>
<li><code><a title="ariadne.message.parser.twilight.Twilight.catch" href="#ariadne.message.parser.twilight.Twilight.catch">catch</a></code></li>
<li><code><a title="ariadne.message.parser.twilight.Twilight.gen_sparkle" href="#ariadne.message.parser.twilight.Twilight.gen_sparkle">gen_sparkle</a></code></li>
<li><code><a title="ariadne.message.parser.twilight.Twilight.mixin" href="#ariadne.message.parser.twilight.Twilight.mixin">mixin</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>